//
//  FinderModels.swift
//  LightComicsV2
//
//  Created by LeeSeGun on 2021/12/20.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import FileKit

enum Finder {
    // MARK: Use cases
    
    
    // MARK: Fetch Files
    enum FetchFiles {
        struct Request {
            let path: Path
            let searchKeyword: String? = nil
        }
        
        struct Response {
            var elements: [Path]
        }
        
        struct ViewModel {
            var directories: [Path]
            var files: [Path]
            
            enum Section: Int {
                case Dirs = 0
                case Files = 1
                
                var stringValue: String {
                    switch self {
                    case .Dirs: return R.string.DIRECTORY
                    case .Files: return R.string.FILE
                    }
                }
            }
            
            func indexPathForPath(_ indexPath: IndexPath) -> Path? {
                switch Section(rawValue: indexPath.section) {
                case Section.Dirs?:
                    return directories[safe: indexPath.row]
                case Section.Files?:
                    return files[safe: indexPath.row]
                default:
                    return nil
                }
            }
        }
    }
    
    
    // MARK: Update Sort Rule
    enum UpdateSortRule {
        struct Request {
            let rule: FileSortRule
        }
        struct Response {
            
        }
        struct ViewModel {
            
        }
    }
    
    enum FileSortRule: Int {
        case Name
        case Size
        case Date
        
        var isName: Bool {
            return self == .Name
        }
        var isSize: Bool {
            return self == .Size
        }
        var isDate: Bool {
            return self == .Date
        }
    }
    
    enum FileSortOrder: Int {
        case ASC
        case DESC
        
        var isASC: Bool {
            return self == .ASC
        }
    }
    
    static var currentSortRule: FileSortRule {
        set {
            UserDefaults.standard.set(newValue.rawValue, forKey: "currentSortRule")
            UserDefaults.standard.synchronize()
        }
        get {
            let rawValue = UserDefaults.standard.integer(forKey: "currentSortRule")
            return FileSortRule(rawValue: rawValue) ?? .Name
        }
    }
    
    static var currentSortOrder: FileSortOrder {
        set {
            UserDefaults.standard.set(newValue.rawValue, forKey: "currentSortOrder")
            UserDefaults.standard.synchronize()
        }
        get {
            let rawValue = UserDefaults.standard.integer(forKey: "currentSortOrder")
            return FileSortOrder(rawValue: rawValue) ?? .ASC
        }
    }
    
    
    // MARK: Make Directory
    enum MakeDirectory {
        struct Request {
            var parent: Path
            var dirName: String
        }
        struct Response {
            
        }
        struct ViewModel {
            
        }
    }

    
    enum RenameFile {
        struct Request {
            let newName: String
            let targetPath: Path
        }
        struct Response {
            
        }
        struct ViewModel {
            
        }
    }
    
    enum MoveFiles {
        struct Request {
            let paths: [Path]
            let moveDirectoryPath: Path
        }
        struct Response {
            
        }
        struct ViewModel {
            
        }
    }

    enum MoveTrash {
        struct Request {
            let paths: [Path]
        }
        struct Response {
            
        }
        struct ViewModel {
            
        }
    }
    
    enum Share {
        struct Request {
            let paths: [Path]
        }
        struct Response {
            
        }
        struct ViewModel {
            
        }
    }
}



// MARK: -
extension Array where Iterator.Element == Path {
    mutating func sort() {
        sort { a, b in
            switch Finder.currentSortRule {
            case .Name:
                if Finder.currentSortOrder.isASC {
                    return a.fileName.localizedStandardCompare(b.fileName) == .orderedAscending
                }
                return a.fileName.localizedStandardCompare(b.fileName) == .orderedDescending
            case .Size:
                if Finder.currentSortOrder.isASC {
                    return a.fileSize ?? 0 < b.fileSize ?? 0
                }
                return a.fileSize ?? 0 > b.fileSize ?? 0
            case .Date:
                if Finder.currentSortOrder.isASC {
                    return a.creationDate?.timeIntervalSince1970 ?? 0 < b.creationDate?.timeIntervalSince1970 ?? 0
                }
                return a.creationDate?.timeIntervalSince1970 ?? 0 > b.creationDate?.timeIntervalSince1970 ?? 0
                
            }
        }
    }
}
